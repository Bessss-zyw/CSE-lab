## CSE lab3 文档

*518021911211 张懿雯*



#### Part 1 Basic

第一部分只要求利用*extent_server*为*ydb_server*实现最基础的*transaction*，不需要考虑并发，因此设计也非常简单。

- *transaction_begin*：无需操作，直接返回 *ydb_protocol::OK*
- *transaction_commit*：无需操作，直接返回 *ydb_protocol::OK*
- *transaction_abort*：无需操作，直接返回 *ydb_protocol::OK*
- *get*：对 *key* 做哈希得到 *eid*，调用 *extent_server* 的 *get* 来读取 *eid* 中的 *value*
- *set*：对 *key* 做哈希得到 *eid*，调用 *extent_server* 的 *set* 将 *value* 写入 *eid* 
- *del*：和 *set* 操作相同，唯一区别是此处的 *value* 是一个空字符串



#### Part 2 2PL

第二部分要求用*2PL*实现*transaction*，需要考虑并发。因此在这里开始使用到了之前*lab2*里实现的 *lock_server*，并在*ydb_server* 中增加以下几个**数据结构**：

- `ydb_protocol::transaction_id current_transaction;` 用于记录当前最高 *transaction_id* 

- ```c++
  struct trans_lock {
     extent_protocol::extentid_t eid;
     char *oldContent;
     int writen; // the size of the oldContent
     struct trans_lock *next;
  };
  
  std::map <ydb_protocol::transaction_id, struct trans_lock*> trans_record;
  ```

  *ydb_server* 中的锁是细粒度锁，每个 *eid* 对应一把锁，需要一个数据结构来记录拿放锁情况。 *trans_lock* 数据结构中的 *eid* 即该锁对应的 *eid*， *old_content* 记录其修改前内容（如果有写操作的话），*written*是其写入的大小（若当前*transaction*没有对该*eid*进行写操作则为-1）。 *trans_lock*可以形成一张链表，用来记录一个 *transaction* 对各个 *eid* 的拿放锁情况，以及一些写入信息。*trans_record* 即对所有 *transaction* 拿放锁情况的记录。

- ```c++
  std::map <ydb_protocol::transaction_id, extent_protocol::extentid_t> trans_req_lock;
  std::map <extent_protocol::extentid_t, ydb_protocol::transaction_id> lock_holder;
  ```

  为了方便做死锁检测，添加 *trans_req_lock* 和 *lock_holder*。前者记录每个 *transaction* 当前正在 *acquire* 的锁，后者记录每个 *eid* 对应的锁在哪个 *transaction* 手里。

*ydb_server*中具体各个函数**代码实现**大致如下：

- *transaction_begin*：拿到全局锁，将*current_transaction*值赋给*out_id* ，*current_transaction++*，放掉全局锁
- *transaction_commit*：检查*trans_id*合法性，释放其对应的*trans_lock* 链表，该 *transaction* 结束
- *transaction_abort*：检查*trans_id*合法性，根据*trans_lock* 链表回滚其写操作（将 *write* 过的 *eid* 的旧值写回），释放其对应的*trans_lock* 链表，该 *transaction* 结束
- *get*：检查*trans_id*合法性，对 *key* 做哈希得到 *eid*，查看*trans_lock* 链表，如果还未拿到该 *eid* 对应的锁就去问*lock_server*要，最后调用 *extent_server* 的 *get* 来读取 *eid* 中的 *value*
- *set*：检查*trans_id*合法性，对 *key* 做哈希得到 *eid*，查看*trans_lock* 链表，如果还未拿到该 *eid* 对应的锁就去问*lock_server*要，如果该*transaction*未进行股票写操作则读取 *eid* 中的已有 *value* 记录到*oldContent*，最后调用 *extent_server* 的 *set* 将 *value* 写入 *eid* 
- *del*：和 *set* 操作相同，唯一区别是此处的 *value* 是一个空字符串

*注：拿细粒度锁前都需要做死锁检查，若可能产生死锁情况，则abort*



#### Part 3 OCC

第三部分要求用*OCC*实现*transaction*，需要考虑并发。在*ydb_server* 中增加以下几个**数据结构**：

- `ydb_protocol::transaction_id current_transaction;` 用于记录当前最高 *transaction_id* 

- ```c++
  struct record {
     extent_protocol::extentid_t eid;
     char *value;
     size_t size;
     struct record *next;
  };
  
  std::map <ydb_protocol::transaction_id, struct record*> trans_read;
  std::map <ydb_protocol::transaction_id, struct record*> trans_write;
  ```

  *record* 数据结构可以保存一个*key-value pair*， 它可以形成一张链表，用来记录一个 *transaction* 对各个 *eid* 的操作情况。*trans_read* 即所有 *transaction* 读取记录，*trans_write* 即所有 *transaction* 写入记录。

*ydb_server*中具体各个函数**代码实现**大致如下：

- *transaction_begin*：同 *part2*
- *transaction_commit*：检查*trans_id*合法性，检查其 *read set* 是否被写过，是则 *abort*； 否则 *commit* 其 *write set* （在检查和*commit*时需要拿全局锁），而后释放其对应的*trans_lock* 链表，该 *transaction* 结束
- *transaction_abort*：检查*trans_id*合法性，释放其对应的*trans_lock* 链表，该 *transaction* 结束
- *get*：检查*trans_id*合法性，对 *key* 做哈希得到 *eid*，查看写入 *record* 链表，若写入过则返回写入值，查看读取 *record* 链表，如果还未读过该 *eid* 就调用 *extent_server* 的 *get* 来读取 *eid* 中的 *value*，若读过则返回之前的读取值
- *set*：检查*trans_id*合法性，对 *key* 做哈希得到 *eid*，调用 *extent_server* 的 *set* 将 *value* 写入 *eid* ，并将该 *value* 记录到写入 *record* 链表
- *del*：和 *set* 操作相同，唯一区别是此处的 *value* 是一个空字符串

